---
title: "OASIS‑1 MRI — cyclic shift SKPD"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(Matrix)
library(RNifti)
library(readxl)
library(pROC)       
library(ggplot2)
source("skpd_tensor_utils.R")
source("skpd_classifier.R")
```

## load data

```{r}
# ---- paths -----------------------------------------------------------
mri_dir    <- "//wsl$/Ubuntu/home/jackie/Research/MRI/CS_SKPD/CS-SKPD/OASIS1_416_masked"
excel_path <- "//wsl$/Ubuntu/home/jackie/Research/MRI/CS_SKPD/CS-SKPD/oasis_adj_subjectdata.xlsx"

# ---------- 1. scan folder, load *.nii -------------------------------
nii_files <- list.files(mri_dir, pattern = "\\.nii$", full.names = TRUE)
cat("Total number of .nii files:", length(nii_files), "\n")

mri_data_list <- list()
expected_shape <- NULL

for (f in nii_files) {
  base <- basename(f)
  # extract 4-digit patient id between first two underscores
  id_chr <- sub("^[^_]*_(\\d{4}).*$", "\\1", base)
  if (id_chr == base) {           # extraction failed
    message("Skip: cannot parse ID from ", base)
    next
  }
  id <- as.integer(id_chr)

  # load volume
  vol <- tryCatch(as.array(readNifti(f)), error = function(e) NULL)
  if (is.null(vol)) {
    message("Skip: failed to read ", base)
    next
  }

  # first shape becomes reference
  if (is.null(expected_shape)) {
    expected_shape <- dim(vol)
    cat("First MRI dims (patient", id, "):",
        paste(expected_shape, collapse="×"), "\n")
  } else if (!identical(dim(vol), expected_shape)) {
    message("Skip: shape mismatch for ", id,
            " (expected ", paste(expected_shape, collapse="×"),
            ", got ", paste(dim(vol), collapse="×"), ")")
    next
  }

  mri_data_list[[as.character(id)]] <- vol
}

# ---------- 2. resize all to 64×64×64 (linear interp) ----------------
resize_linear <- function(arr, out_dim = c(64,64,64)) {
  # collapse any singleton dims
  while (length(dim(arr)) > 3) arr <- arr[,,,1, drop = FALSE]
  stopifnot(length(dim(arr)) == 3)

  # factors for ndimage.zoom-style scaling
  in_dim <- dim(arr)
  grid_x <- seq(1, in_dim[1], length.out = out_dim[1])
  grid_y <- seq(1, in_dim[2], length.out = out_dim[2])
  grid_z <- seq(1, in_dim[3], length.out = out_dim[3])

  # trilinear interpolation via base R (fast enough for 416 vols)
  out <- array(0, dim = out_dim)
  for (i in seq_along(grid_x)) {
    x0 <- floor(grid_x[i]); x1 <- min(x0 + 1, in_dim[1])
    dx <- grid_x[i] - x0
    for (j in seq_along(grid_y)) {
      y0 <- floor(grid_y[j]); y1 <- min(y0 + 1, in_dim[2])
      dy <- grid_y[j] - y0
      for (k in seq_along(grid_z)) {
        z0 <- floor(grid_z[k]); z1 <- min(z0 + 1, in_dim[3])
        dz <- grid_z[k] - z0
        c000 <- arr[x0, y0, z0]
        c001 <- arr[x0, y0, z1]
        c010 <- arr[x0, y1, z0]
        c011 <- arr[x0, y1, z1]
        c100 <- arr[x1, y0, z0]
        c101 <- arr[x1, y0, z1]
        c110 <- arr[x1, y1, z0]
        c111 <- arr[x1, y1, z1]
        c00  <- c000*(1-dx) + c100*dx
        c01  <- c001*(1-dx) + c101*dx
        c10  <- c010*(1-dx) + c110*dx
        c11  <- c011*(1-dx) + c111*dx
        c0   <- c00*(1-dy) + c10*dy
        c1   <- c01*(1-dy) + c11*dy
        out[i,j,k] <- c0*(1-dz) + c1*dz
      }
    }
  }
  out
}

resized_mri <- lapply(mri_data_list, resize_linear)

# ---------- 3. Z-score each volume -----------------------------------
scaled_mri <- lapply(resized_mri, function(v) (v - mean(v)) / sd(as.vector(v)))

# ---------- 4. align with Excel IDs ----------------------------------
# use Numeric_ID extraction identical to Python:
meta <- readxl::read_excel(excel_path) |>
  dplyr::mutate(num_id = as.integer(stringr::str_extract(ID, "\\d{4}"))) |>
  dplyr::filter(num_id %in% names(mri_data_list)) |>
  dplyr::mutate(label = as.integer(CDR > 0)) |>
  dplyr::select(num_id, label)

X_list <- scaled_mri[ as.character(meta$num_id) ]
Y      <- meta$label
```

## MODEL prepare

```{r}
hp <- list(
  p1 = 8,  d1 = 8,
  p2 = 8,  d2 = 8,
  p3 = 8,  d3 = 8,          # 8×8 blocks → 64×64×64 voxels
  term         = 3,
  lmbda_a      = 0.1,
  lmbda_b      = 0.1,
  lmbda_gamma  = 0.5,
  alpha        = 0.2,
  normalization_A = TRUE,
  normalization_B = FALSE,
  use_cyclic      = TRUE
)
hp$s1 <- hp$p1 * hp$p2 * hp$p3        # = 512
hp$s2 <- hp$d1 * hp$d2 * hp$d3 


meta <- readxl::read_excel(excel_path) |>
  dplyr::mutate(
    `M/F` = ifelse(`M/F` == "M", 1, 0),
    AD    = as.integer(CDR > 0),
    num_id = as.integer(stringr::str_extract(ID, "\\d{4}"))
  ) |>
  tidyr::drop_na(num_id)

continuous_cols <- c("Age", "eTIV", "nWBV", "ASF")
Z_continuous <- scale(meta[continuous_cols])
Z_categorical <- as.matrix(meta[,"M/F"])
Z_cov <- cbind(Z_categorical, Z_continuous)

## align volumes with meta rows
meta <- meta[meta$num_id %in% names(volumes), ]
X_list <- volumes[ as.character(meta$num_id) ]
Y_vec  <- meta$AD
Z_cov  <- Z_cov[match(meta$num_id, meta$num_id), ]


set.seed(42)
idx <- sample(seq_along(X_list))
train_idx <- idx[1:floor(0.8*length(idx))]
val_idx   <- idx[-train_idx]

make_D <- function(i) list(X_list[[i]], X_list[[i]], Y_vec[i], Z_cov[i,])

Ds_train <- lapply(train_idx, make_D)
Ds_val   <- lapply(val_idx,   make_D)

```

## fit model

```{r}
model <- SKPD_LogisticRegressor_Cyclic$new(hp, Ds = Ds_train,
                                           max_iter = 100, verbose = TRUE)
model$fit()
```

## accuracy

```{r}
X_val  <- lapply(Ds_val, `[[`, 1)
X2_val <- lapply(Ds_val, `[[`, 2)
Y_val  <- Y_vec[val_idx]

p_hat <- model$predict_proba(X_val, X2_val)
auc   <- as.numeric(pROC::auc(Y_val, p_hat))
acc   <- mean((p_hat > 0.5) == Y_val)

cat(sprintf("Validation  AUC = %.3f\n", auc))
cat(sprintf("Validation  ACC = %.3f\n", acc))
```

## Estimated C

```{r}
reconstruct_C <- function(mod)
  Reduce("+", lapply(seq_len(mod$term),
         function(r) tcrossprod(mod$A1[r, ], mod$B1[r, ])))

C_hat_vec <- reconstruct_C(model)
mat2ten   <- Mat2TenOperator$new(8,8,8,8,8,8)
C_estimate_mri <- mat2ten$forward(C_hat_vec)

## visualize central slice
mid <- ceiling(dim(C_estimate_mri)[3]/2)
image(t(apply(C_estimate_mri[,,mid], 2, rev)),
      col = terrain.colors(20), useRaster = TRUE,
      main = paste("Estimated coefficient – slice", mid), axes = FALSE)
```
